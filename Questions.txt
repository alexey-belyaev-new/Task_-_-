1. Что такое Uniform initialization, чем отличается от Aggregate initialization? 
Uniform initialization – возможность инициализации объекта с помощью фигурных скобок 
Int i{} //инициализация нулем
Int i{5} //инициализация числом 5
Запрещены сужающие преобразования
Int i{3.5} //ошибка
Aggregate initialization – инициализация агрегата
Агрегат - называется массив или объект типа класс, не имеющий конструкторов, частных или защищенных членов, базовых классов и виртуальных функций
int i[4] = {0, 1, 0, 1};
class A {public: int b; int c;};
A a { 1,2 }; //инициализирует b = 1, c = 2
2. Что такое copy elision? 
copy elision - это оптимизация, при которой компилятор может убрать некоторые вызовы конструктора копирования и деструктора, при возврате объекта из функции, и только если тип возвращаемого объекта полностью совпадает с типом функции.
При соблюдении этих критериев реализации разрешается пропустить конструкцию копирования объекта класса, даже если конструктор, выбранный для операции копирования, или деструктор для объекта имеют побочные эффекты 
class A
{
public:
	A() { cout << "M()" << endl; }
};

A func()
{
	A a_func; // пропустит создание объекта
	return a_func;
}

int main()
{
	A a = func(); //будет создан 1 объект, промежуточные временные объекты не будут созданы
	return 0;
}

3.Что такое move-семантика? 
move-семантика – инструмент языка, который предназначен для осуществления перемещения данных во время инициализации и конструирования новых объектов, что позволяет сократить издержки на копирование
int main()
{
    string strOld{ "asdsefsefsfe" }; //строка в 12 символов
    string strNew = move(strOld); //перемещаем строку

    cout << "size of strOld is " << strOld.size() << endl; //выведет 0
    cout << "size of strNew is " << strNew.size() << endl; //выведет 12
    cout << "strOld value " << strOld << endl; //ничего не выведет
    cout << "strNew value " << strNew << endl; //выведет строку "asdsefsefsfe"
	return 0;
}
4. Можно ли вызывать исключение в конструкторе? 
Технически возможно, но с большей долей вероятности это приведет к утечке памяти т.к. для не полностью сконструированных объектов не будет вызван деструктор
5. Чем отличается constexpr от const?
Спецификатор – const делает невозможным изменение значения.
Спецификатор – constexpr обязывает присвоить значение на этапе компиляции
